install.packages("dslabs")
library(dslabs)
a <- 1
b <- 1
c <- -1
(-b + sqrt(b^2 - 4*a*c) ) / ( 2*a )
(-b - sqrt(b^2 - 4*a*c) ) / ( 2*a )
ls
ls()
print(a)
log(8)
log(a)
log(c)
?log
args(log)
log(8,2)
log(9,3)
log(base = 2, x = 8)
2^3
data()
co2
pi
inf
solution_1 <- (-b + sqrt(b^2 - 4*a*c)) / (2*a)
solution_2 <- (-b - sqrt(b^2 - 4*a*c)) / (2*a)
a >- 2
a <- 2
class(a)
class(ls)
class(class)
library(dslabs)
data("murders")
class(murders)
str(murders)
head(murders)
murders$population
names(murders)
class(murders$population)
pop = murders$population
len(pop)
pop
pop <- murders$population
length(pop)
pop = murders$population
length(pop)
"a"
class(murders$population)
class(murders$stae)
class(murders$state)
z <- 3==2
z
class(z)
class(murders$region)
levels(murders$region)
# Loading library and dataset
library(dslabs)
data("murders")
# Some basic operations
a <- 2
class(a)
class(ls)
class(class)
class(murders)
# Structure of dataframe
str(murders)
# Head of dataframe
head(murders)
# Names of columns
names(murders)
# Class of single column
class(murders$population)
# Length of the single column vector
pop = murders$population
length(pop)
# Character Vector
class(murders$state)
# Logical Vector
z <- 3==2
class(z)
# Factor vector
class(murders$region)
# Unique values in factor
levels(murders$region)
# Number of levels
length(levels(murders$region))
# Rows in each level
table(murders$region)
# Another way of accessing a column
murders[["population"]]
identical(murders[["population"]],murders$population)
clear
clear)
clear()
cls()
setwd("~/my_projects/R Basics")
pwd
# Generate Sequence
seq(1:10)
# Generate Sequence
seq(1,10)
1:10
# Generate Sequence
s1 = seq(1,10)
s2 = 1:10
sum(s1)
sum(s2)
setwd("~/my_projects/R-basics")
# Loading library and dataset
library(dslabs)
data("murders")
# Some basic operations
a <- 2
class(a)
class(ls)
class(class)
class(murders)
# Structure of dataframe
str(murders)
# Head of dataframe
head(murders)
# Names of columns
names(murders)
# Class of single column
class(murders$population)
# Length of the single column vector
pop = murders$population
length(pop)
# Character Vector
class(murders$state)
# Logical Vector
z <- 3==2
class(z)
# Factor vector
class(murders$region)
# Unique values in factor
levels(murders$region)
# Number of levels
length(levels(murders$region))
# Rows in each level
table(murders$region)
# Another way of accessing a column
murders[["population"]]
identical(murders[["population"]],murders$population)
# Generate Sequence
s1 = seq(1,10)
s2 = 1:10
sum(s1)
sum(s2)
# Loading library and dataset
library(dslabs)
# Vectors - basic building blocks of dataframes, used to store data.
# Each column of dataframe is a vector
# Create a vector with concatenate function c()
codes <- c(380, 124, 818)
codes
# Create character vector.
# Without quotes character will be taken as variable names
country <- c("italy", "canada", "egypt")
# Names of vectors
codes <- c(italy = 380, canada = 124, egypt = 818)
codes
# Class is still numeric
class(codes)
# But with names accessed using names() function
names(codes)
# Another way to declare vector with names
# Now quotes using quotes is same as before
codes <- c("italy" = 380, "canada" = 124, "egypt" = 818)
codes
# Assign names using names function
codes <- c(380, 124, 818)
country <- c("italy","canada","egypt")
names(codes) <- country
codes
# Sequences also create vetors
seq(1, 10)
seq(1, 10, 2)
1:10
class(1:10)
class(seq(1, 10, 0.5))
# Subsetting
codes[2]
# Accessing multiple enteries by using vector as index
codes[c(1,3)]
# Or by using sequence
codes[1:2]
# Using names single or multiple
codes["canada"]
codes[c("egypt","italy")]
# Vector Coercion
x <- c(1,"canada",3)
x
# 1 and 3 converted to character. R coerced data to character
class(x)
x <- 1:5
y <- as.character(x)
class(y)
y <- as.numeric(y)
class(y)
x <- c("1","b","3")
as.numeric(x)
# NA introduced by coercion
#Loading library and dataset
library(dslabs)
# Sorting
data(murders)
# Sorting by murders
sort(murders$total)
# Get states sorted my murders
ind <- order(murders$total)
murders$state[ind]
# in a single line
murders$state[order(murders$total)]
# max
max(murders$total)
# which.max index of max
which.max(murders$total)
murders$state[which.max(murders$total)]
# Rank
x <- c(31, 4, 15, 92, 65)
rank(x)
# Recycling in case of length mismatch
x <- c(1,2,3)
y <- c(10, 20, 30, 40, 50, 60, 70)
x+y
#Loading library and dataset
library(dslabs)
# Vector Arthimetics
# Operations on vectors occur element wise
inches <- c(69, 62, 66, 70, 70, 73, 67, 73, 67, 70)
inches * 2.54
inches - 69
murder_rate <- murders$total / murders$population * 100000
# State with highest murder rate
murders$state[order(murder_rate)]
murders$state[order(murder_rate,decreasing = TRUE)]
x <- c(2, 43, 27, 96, 18)
rank(x)
order(x)
sort(x)
?order
50/60
10/60
(0.8/10)*60
(4/50)*60
(3.1/30)*60
# Indexing Vectors
index = murder_rate < 0.71
index = murder_rate <= 0.71
# Indexing Vectors
index = murder_rate < 0.71
index
index = murder_rate <= 0.71
index
murders$state[index]
sum(index)
west <- murders$region == "West"
safe <- murder_rate <= 1
ind <- safe & west
murders$state[ind]
# Which used to get index of row matching condition
ind <- which(murders$state == "California")
murder_rate[ind]
atch each of the entries of a first vector:
ind <- match(c("New York", "Florida", "Texas"), murders$state)
ind
# match unction tells us which indexes of a second vector
# match each of the entries of a first vector:
ind <- match(c("New York", "Florida", "Texas"), murders$state)
ind
c("Boston", "Dakota", "Washington") %in% murders$state
# %in% function used when If rather than an index we want a logical that tells us
# whether or not each element of a first vector is in a second vector
c("Boston", "Dakota", "Washington") %in% murders$state
match(c("New York", "Florida", "Texas"), murders$state)
which(murders$state%in%c("New York", "Florida", "Texas"))
